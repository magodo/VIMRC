{
    "testcase": {
        "prefix": "testcase",
        "body": [
            "func Test$1(t *testing.T) {",
            "\tcases := []struct {",
            "\t}{",
            "\t\t{",
            "\t\t},",
            "\t}",
            "",
            "\tfor idx, c := range cases {",
            "\t\tout := $2",
            "\t\trequire.Equal(t, c.expect, out, idx)",
            "\t}",
            "}"
        ]
    },

    "acc test scaffolding for resource": {
        "prefix": "tfacctest_res",
        "body": [
            "type $1Resource struct{}",
            "",
            "func TestAcc$1_basic(t *testing.T) {",
            "\tdata := acceptance.BuildTestData(t, \"azurerm_$4\", \"test\")",
            "\tr := $1Resource{}",
            "",
            "\tdata.ResourceTest(t, r, []resource.TestStep{",
            "\t\t{",
            "\t\t\tConfig: r.basic(data),",
            "\t\t\tCheck: resource.ComposeTestCheckFunc(",
            "\t\t\t\tcheck.That(data.ResourceName).ExistsInAzure(r),",
            "\t\t\t),",
            "\t\t},",
            "\t\tdata.ImportStep(),",
            "\t})",
            "}",
            "",
            "func TestAcc$1_complete(t *testing.T) {",
            "\tdata := acceptance.BuildTestData(t, \"azurerm_$4\", \"test\")",
            "\tr := $1Resource{}",
            "",
            "\tdata.ResourceTest(t, r, []resource.TestStep{",
            "\t\t{",
            "\t\t\tConfig: r.complete(data),",
            "\t\t\tCheck: resource.ComposeTestCheckFunc(",
            "\t\t\t\tcheck.That(data.ResourceName).ExistsInAzure(r),",
            "\t\t\t),",
            "\t\t},",
            "\t\tdata.ImportStep(),",
            "\t})",
            "}",
            "",
            "func TestAcc$1_update(t *testing.T) {",
            "\tdata := acceptance.BuildTestData(t, \"azurerm_$4\", \"test\")",
            "\tr := $1Resource{}",
            "",
            "\tdata.ResourceTest(t, r, []resource.TestStep{",
            "\t\t{",
            "\t\t\tConfig: r.basic(data),",
            "\t\t\tCheck: resource.ComposeTestCheckFunc(",
            "\t\t\t\tcheck.That(data.ResourceName).ExistsInAzure(r),",
            "\t\t\t),",
            "\t\t},",
            "\t\tdata.ImportStep(),",
            "\t\t{",
            "\t\t\tConfig: r.complete(data),",
            "\t\t\tCheck: resource.ComposeTestCheckFunc(",
            "\t\t\t\tcheck.That(data.ResourceName).ExistsInAzure(r),",
            "\t\t\t),",
            "\t\t},",
            "\t\tdata.ImportStep(),",
            "\t\t{",
            "\t\t\tConfig: r.basic(data),",
            "\t\t\tCheck: resource.ComposeTestCheckFunc(",
            "\t\t\t\tcheck.That(data.ResourceName).ExistsInAzure(r),",
            "\t\t\t),",
            "\t\t},",
            "\t\tdata.ImportStep(),",
            "\t})",
            "}",
            "",
            "func TestAcc$1_requiresImport(t *testing.T) {",
            "\tdata := acceptance.BuildTestData(t, \"azurerm_$4\", \"test\")",
            "\tr := $1Resource{}",
            "",
            "\tdata.ResourceTest(t, r, []resource.TestStep{",
            "\t\t{",
            "\t\t\tConfig: r.basic(data),",
            "\t\t\tCheck: resource.ComposeTestCheckFunc(",
            "\t\t\t\tcheck.That(data.ResourceName).ExistsInAzure(r),",
            "\t\t\t),",
            "\t\t},",
            "\t\tdata.RequiresImportErrorStep(r.requiresImport),",
            "\t})",
            "}",
            "",
            "func (r $1Resource) Exists(ctx context.Context, clients *clients.Client, state *terraform.InstanceState) (*bool, error) {",
            "\tclient := clients.$2.$3Client",
            "",
            "\tid, err := parse.$1ID(state.ID)",
            "\tif err != nil {",
            "\t\treturn nil, err",
            "\t}",
            "",
            "\tif resp, err := client.Get(ctx, id.ResourceGroup, id.$1Name); err != nil {",
            "\t\tif !response.WasNotFound(resp.HttpResponse) {",
            "\t\t\treturn pointers.To(false), nil",
            "\t\t}",
            "\t\treturn nil, fmt.Errorf(\"retrieving %s: %+v\", id, err)",
            "\t}",
            "",
            "\treturn pointers.To(true), nil",
            "}",
            "",
            "func (r $1Resource) basic(data acceptance.TestData) string {",
            "\ttemplate := r.template(data)",
            "\treturn fmt.Sprintf(`",
            "%s",
            "",
            "resource \"azurerm_$4\" \"test\" {",
            "}",
            "`, template)",
            "}",
            "",
            "func (r $1Resource) complete(data acceptance.TestData) string {",
            "\ttemplate := r.template(data)",
            "\treturn fmt.Sprintf(`",
            "%s",
            "",
            "resource \"azurerm_$4\" \"test\" {",
            "}",
            "`, template)",
            "}",
            "",
            "func (r $1Resource) requiresImport(data acceptance.TestData) string {",
            "\ttemplate := r.basic(data)",
            "\treturn fmt.Sprintf(`",
            "%s",
            "",
            "resource \"azurerm_$4\" \"import\" {",
            "}",
            "`, template)",
            "}",
            "",
            "func (r $1Resource) template(data acceptance.TestData) string {",
            "\treturn fmt.Sprintf(`",
            "`)",
            "}"
        ]
    },
    "acc test scaffolding for data source": {
        "prefix": "tfacctest_ds",
        "body": [
            "type $1DataSource struct{}",
            "",
            "func TestAccDataSource$1_basic(t *testing.T) {",
            "\tdata := acceptance.BuildTestData(t, \"data.azurerm_$2\", \"test\")",
            "\td := $1DataSource{}",
            "\tr := $1Resource{}",
            "",
            "\tdata.DataSourceTest(t, []resource.TestStep{",
            "\t\t{",
            "\t\t\tConfig: d.basic(data, r),",
            "\t\t\tCheck: resource.ComposeTestCheckFunc(",
            "\t\t\t\tcheck.That(data.ResourceName).Key(\"$3\").Exists(),",
            "\t\t\t),",
            "\t\t},",
            "\t})",
            "}",
            "",
            "func (d $1DataSource) basic(data acceptance.TestData, r $1Resource) string {",
            "\tconfig := r.basic(data)",
            "\treturn fmt.Sprintf(`",
            "%s",
            "",
            "data \"azurerm_$2\" \"test\" {",
            "  name = azurerm_$2.test.name",
            "}",
            "`, config)",
            "}"
        ]
    },
    "declare TF resource": {
        "prefix": "tfdeclres",
        "body": [
            "type $1Resource struct {}",
            "",
            "var _ sdk.ResourceWithUpdate = $1Resource{}",
            "",
            "type $1Model struct {",
            "\tName           string                 `tfschema:\"name\"`",
            "\tResourceGroup  string                 `tfschema:\"resource_group_name\"`",
            "\tTags           map[string]interface{} `tfschema:\"tags\"`",
            "}",
            "",
            "func (r $1Resource) Arguments() map[string]*pluginsdk.Schema {",
            "\treturn map[string]*pluginsdk.Schema{",
            "\t\t\"name\": {",
            "\t\t\tType:         pluginsdk.TypeString,",
            "\t\t\tRequired:     true,",
            "\t\t\tForceNew:     true,",
            "\t\t\tValidateFunc: validation.$1Name,",
            "\t\t},",
            "\t\t\"resource_group_name\": azure.SchemaResourceGroupName(),",
            "\t\t\"tags\": tags.ForceNewSchema(),",
            "\t}",
            "}",
            "",
            "func (r $1Resource) Attributes() map[string]*pluginsdk.Schema {",
            "\treturn map[string]*pluginsdk.Schema{}",
            "}",
            "",
            "func (r $1Resource) ResourceType() string {",
            "\treturn \"azurerm${3}\"",
            "}",
            "",
            "func (r $1Resource) ModelObject() interface{} {",
            "\treturn &$1Model{}",
            "}",
            "",
            "func (r $1Resource) IDValidationFunc() pluginsdk.SchemaValidateFunc {",
            "\treturn validate.$1ID",
            "}",
            "",
            "func (r $1Resource) Create() sdk.ResourceFunc {",
            "\treturn sdk.ResourceFunc{",
            "\t\tTimeout: 30 * time.Minute,",
            "\t\tFunc: func(ctx context.Context, metadata sdk.ResourceMetaData) error {",
            "\t\t\tclient := metadata.Client.$2.$1sClient",
            "\t\t\tsubscriptionId := metadata.Client.Account.SubscriptionId",
            "",
            "\t\t\tvar plan $1Model",
            "\t\t\tif err := metadata.Decode(&plan); err != nil {",
            "\t\t\t\treturn fmt.Errorf(\"decoding %+v\", err)",
            "\t\t\t}",
            "",
            "\t\t\tid := parse.New$1ID(subscriptionId, plan.ResourceGroup, plan.Name)",
            "\t\t\texisting, err := client.Get(ctx, id.ResourceGroup, id.Name)",
            "\t\t\tif err != nil {",
            "\t\t\t\tif !response.WasNotFound(existing.HttpResponse) {",
            "\t\t\t\t\treturn fmt.Errorf(\"checking for presence of existing %s: %+v\", id, err)",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif !response.WasNotFound(existing.HttpResponse) {",
            "\t\t\t\treturn metadata.ResourceRequiresImport(r.ResourceType(), id)",
            "\t\t\t}",
            "",
            "\t\t\t// TODO: construct params from model",
            "",
            "\t\t\tfuture, err = client.CreateOrUpdate(ctx, id.ResourceGroup, id.Name, params)",
            "\t\t\tif err != nil {",
            "\t\t\t\treturn fmt.Errorf(\"creating %s: %+v\", id, err)",
            "\t\t\t}",
            "\t\t\tif err := future.WaitForCompletionRef(ctx, client.Client); err != nil {",
            "\t\t\t\treturn fmt.Errorf(\"waiting for creation of %s: %+v\", id, err)",
            "\t\t\t}",
            "\t\t\t",
            "\t\t\tmetadata.SetID(id)",
            "\t\t\treturn nil",
            "\t\t},",
            "\t}",
            "}",
            "",
            "func (r $1Resource) Read() sdk.ResourceFunc {",
            "\treturn sdk.ResourceFunc{",
            "\t\tTimeout: 5 * time.Minute,",
            "",
            "\t\tFunc: func(ctx context.Context, metadata sdk.ResourceMetaData) error {",
            "\t\t\tclient := metadata.Client.$2.$1sClient",
            "\t\t\tid, err := parse.$1ID(metadata.ResourceData.Id())",
            "\t\t\tif err != nil {",
            "\t\t\t\treturn err",
            "\t\t\t}",
            "",
            "\t\t\texisting, err := client.Get(ctx, id.ResourceGroup, id.Name)",
            "\t\t\tif err != nil {",
            "\t\t\t\tif response.WasNotFound(existing.HttpResponse) {",
            "\t\t\t\t\treturn metadata.MarkAsGone(id)",
            "\t\t\t\t}",
            "\t\t\t\treturn fmt.Errorf(\"retrieving %s: %+v\", id, err)",
            "\t\t\t}",
            "",
            "\t\t\t// TODO: construct the params",
            "\t\t\tmodel := $1Model{}",
            "",
            "\t\t\tmodel.Tags = tags.Flatten(existing.Tags)",
            "",
            "\t\t\treturn metadata.Encode(&model)",
            "\t\t},",
            "\t}",
            "}",
            "",
            "func (r $1Resource) Update() sdk.ResourceFunc {",
            "\treturn sdk.ResourceFunc{",
            "\t\tTimeout: 30 * time.Minute,",
            "\t\tFunc: func(ctx context.Context, metadata sdk.ResourceMetaData) error {",
            "\t\t\tid, err := parse.$1ID(metadata.ResourceData.Id())",
            "\t\t\tif err != nil {",
            "\t\t\t\treturn err",
            "\t\t\t}",
            "",
            "\t\t\tvar plan $1Model",
            "\t\t\tif err := metadata.Decode(&plan); err != nil {",
            "\t\t\t\treturn err",
            "\t\t\t}",
            "",
            "\t\t\tclient := metadata.Client.$2.$1sClient",
            "",
            "\t\t\tparams, err := client.Get(ctx, id.ResourceGroup, id.Name)",
            "\t\t\tif err != nil {",
            "\t\t\t\treturn fmt.Errorf(\"retrieving %s: %+v\", id, err)",
            "\t\t\t}",
            "",
            "\t\t\t// TODO: update the params",
            "\t\t\t// if props := params.Properties; props != nil {",
            "\t\t\t// \tif metadata.ResourceData.HasChange(\"xxx\") {",
            "\t\t\t// \t\tprops.Xxx = plan.Xxx",
            "\t\t\t// \t}",
            "",
            "\t\t\tfuture, err := client.CreateOrUpdate(ctx, id.ResourceGroup, id.Name, params)",
            "\t\t\tif err != nil {",
            "\t\t\t\treturn fmt.Errorf(\"updating %s: %+v\", id, err)",
            "\t\t\t}",
            "\t\t\tif err := future.WaitForCompletionRef(ctx, client.Client); err != nil {",
            "\t\t\t\treturn fmt.Errorf(\"waiting for update of %s: %+v\", id, err)",
            "\t\t\t}",
            "",
            "\t\t\treturn nil",
            "\t\t},",
            "\t}",
            "}",
            "",
            "func (r $1Resource) Delete() sdk.ResourceFunc {",
            "\treturn sdk.ResourceFunc{",
            "\t\tTimeout: 30 * time.Minute,",
            "\t\tFunc: func(ctx context.Context, metadata sdk.ResourceMetaData) error {",
            "\t\t\tclient := metadata.Client.$2.$1sClient",
            "",
            "\t\t\tid, err := parse.$1ID(metadata.ResourceData.Id())",
            "\t\t\tif err != nil {",
            "\t\t\t\treturn err",
            "\t\t\t}",
            "",
            "\t\t\tfuture, err := client.Delete(ctx, id.ResourceGroup, id.Name)",
            "\t\t\tif err != nil {",
            "\t\t\t\treturn fmt.Errorf(\"deleting %s: %+v\", id, err)",
            "\t\t\t}",
            "",
            "\t\t\tif err := future.WaitForCompletionRef(ctx, client.Client); err != nil {",
            "\t\t\t\treturn fmt.Errorf(\"waiting for removal of %s: %+v\", id, err)",
            "\t\t\t}",
            "",
            "\t\t\treturn nil",
            "\t\t},",
            "\t}",
            "}"
        ]
    },
    "declare TF data source": {
        "prefix": "tfdeclds",
        "body": [
            "type $1DataSource struct {}",
            "",
            "var _ sdk.DataSource = $1DataSource{}",
            "",
            "type $1DataSourceModel struct {",
            "\tName           string                 `tfschema:\"name\"`",
            "\tResourceGroup  string                 `tfschema:\"resource_group_name\"`",
            "\tTags           map[string]interface{} `tfschema:\"tags\"`",
            "}",
            "",
            "func (r $1DataSource) Arguments() map[string]*pluginsdk.Schema {",
            "\treturn map[string]*pluginsdk.Schema{",
            "\t\t\"name\": {",
            "\t\t\tType:         pluginsdk.TypeString,",
            "\t\t\tRequired:     true,",
            "\t\t\tForceNew:     true,",
            "\t\t\tValidateFunc: validation.$1Name,",
            "\t\t},",
            "\t\t\"resource_group_name\": azure.SchemaResourceGroupName(),",
            "\t}",
            "}",
            "",
            "func (r $1DataSource) Attributes() map[string]*pluginsdk.Schema {",
            "\treturn map[string]*pluginsdk.Schema{}",
            "}",
            "",
            "func (r $1DataSource) ResourceType() string {",
            "\treturn \"azurerm${3}\"",
            "}",
            "",
            "func (r $1DataSource) ModelObject() interface{} {",
            "\treturn &$1DataSourceModel{}",
            "}",
            "",
            "func (r $1DataSource) Read() sdk.ResourceFunc {",
            "\treturn sdk.ResourceFunc{",
            "\t\tTimeout: 5 * time.Minute,",
            "",
            "\t\tFunc: func(ctx context.Context, metadata sdk.ResourceMetaData) error {",
            "\t\t\tclient := metadata.Client.$2.$1sClient",
            "\t\t\tsubscriptionId := meta.(*clients.Client).Account.SubscriptionId",
            "",
            "\t\t\tvar plan $1Model",
            "\t\t\tif err := metadata.Decode(&plan); err != nil {",
            "\t\t\t\treturn fmt.Errorf(\"decoding %+v\", err)",
            "\t\t\t}",
            "",
            "\t\t\tid := parse.New$1ID(subscriptionId, plan.ResourceGroup, plan.Name)",
            "",
            "\t\t\tresp, err := client.Get(ctx, id.ResourceGroup, id.Name)",
            "\t\t\tif err != nil {",
            "\t\t\t\tif !response.WasNotFound(resp.Response) {",
            "\t\t\t\t\treturn metadata.MarkAsGone(id)",
            "\t\t\t\t}",
            "\t\t\t\treturn fmt.Errorf(\"retrieving %s: %+v\", id, err)",
            "\t\t\t}",
            "",
            "\t\t\t// TODO: construct the params",
            "\t\t\tmodel := $1Model{}",
            "",
            "\t\t\tif err := metadata.Encode(&model); err != nil {",
            "\t\t\t\treturn fmt.Errorf(\"encoding %s: %+v\", id, err)",
            "\t\t\t}",
            "",
            "\t\t\tmetadata.SetID(id)",
            "",
            "\t\t\treturn nil",
            "\t\t},",
            "\t}",
            "}"
        ]
    },
    "terraform expand map": {
        "prefix": "expand_map",
        "body": [
            "func expand$1(input []interface{}) *$2 {",
            "\tif len(input) == 0 || input[0] == nil {",
            "\t\treturn nil",
            "\t}",
            "",
            "\traw := input[0].(map[string]interface{})",
            "\toutput := &$2{",
            "\t}",
            "",
            "\treturn output",
            "}"
        ]
    },
    "terraform expand slice": {
        "prefix": "expand_slice",
        "body": [
            "func expand$1(input []interface{}) *[]$2 {",
            "\tif len(input) == 0 {",
            "\t\treturn nil",
            "\t}",
            "",
            "\tresult := make([]$2, 0)",
            "",
            "\tfor _, e := range input {",
            "\t\tresult = append(result, $3)\t\t\t",
            "\t}",
            "",
            "\treturn &result",
            "}"
        ]
    },
    "terraform flatten map": {
        "prefix": "flatten_map",
        "body": [
            "func flatten$1(input $2) []interface{} {",
            "\tif input == nil {",
            "\t\treturn []interface{}{}",
            "\t}",
            "",
            "\t$0",
            "",
            "\treturn []interface{}{",
            "\t\tmap[string]interface{}{",
            "\t\t},",
            "\t}",
            "}"
        ]
    },
    "terraform flatten slice": {
        "prefix": "flatten_slice",
        "body": [
            "func flatten$1(input *[]$2) []interface{} {",
            "\tif input == nil {",
            "\t\treturn []interface{}{}",
            "\t}",
            "",
            "\toutput := make([]interface{}, 0)",
            "",
            "\tfor _, e := range *input {",
            "\t\toutput = append(output, map[string]interface{}{$3})",
            "\t}",
            "",
            "\treturn output",
            "}"
        ]
    }
}
