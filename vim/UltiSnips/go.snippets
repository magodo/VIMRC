snippet errw "wrap error" b
if $1 != nil {
	$1 = errors.Wrap($1, "$2")
	return $1
}
endsnippet

snippet ierrw "wrap error" b
if $1 err := $2; err != nil {
	err = errors.Wrap(err, "$3")
	return err
}
endsnippet

snippet testcase "simple test case" b
func TestFoo(t *testing.T) {
	cases := []struct {
	}{
		{
		},
	}

	for _, c := range cases {
		out := 
		if out != {
			t.Fatalf()
		}
	}
}
endsnippet

snippet errg "grpc error" b
if $1 != nil {
	return status.Error(codes.$2, "failed to $3: " + $1.Error())
}
endsnippet

###############################################
# terraform azurerm provider
###############################################

snippet tfdeclres "declare resource" b
func resourceArm$1() *schema.Resource {
	return &schema.Resource{
		Create: resourceArm$1Create,
		Read:   resourceArm$1Read,
		Update: resourceArm$1Update,
		Delete: resourceArm$1Delete,

		Importer: azSchema.ValidateResourceIDPriorToImport(func(id string) error {
			_, err := parse.$1ID(id)
			return err
		}),

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(30 * time.Minute),
			Read:   schema.DefaultTimeout(5 * time.Minute),
			Update: schema.DefaultTimeout(30 * time.Minute),
			Delete: schema.DefaultTimeout(30 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"name": {
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: validate$1Name(),
			},

			"location": azure.SchemaLocation(),

			"resource_group_name": azure.SchemaResourceGroupName(),

			$0

			"tags": tags.Schema(),
		},
	}
}
endsnippet

snippet tfdecldat "declare data source" b
func dataSourceArm$1() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceArm$1Read,

		Timeouts: &schema.ResourceTimeout{
			Read: schema.DefaultTimeout(5 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"name": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: validate$1Name(),
			},

			"location": azure.SchemaLocationForDataSource(),

			"resource_group_name": azure.SchemaResourceGroupNameForDataSource(),

			$0

			"tags": tags.SchemaDataSource(),
		},
	}
}
endsnippet

snippet tfdeclblk "declare nested block" b
"$1": {
	Type: schema.TypeList,
	MaxItems: 1,
	$2: true,
	Elem: &schema.Resource{
		Schema: map[string]*schema.Schema {
			$0
		},
	},
},
endsnippet

snippet tfctx "create context" b
client := meta.(*clients.Client).${1:Compute}.${2:VMClient}
ctx, cancel := timeouts.For$3(meta.(*clients.Client).StopContext, d)
defer cancel()
endsnippet

snippet tfimport "check import" b
name := d.Get("name").(string)
resourceGroup := d.Get("resource_group_name").(string)

if features.ShouldResourcesBeImported() {
	resp, err := client.Get(ctx, resourceGroup, name, "")
	if err != nil {
		if !utils.ResponseWasNotFound(resp.Response) {
			return fmt.Errorf("Error checking for existing $1 %q (Resource Group %q): %+v", name, resourceGroup, err)
		}
	}

	if !utils.ResponseWasNotFound(resp.Response) {
		return tf.ImportAsExistsError("azurerm${1/(\w+)\s*/_\L$1\E/g}", *resp.ID)
	}
}
endsnippet

snippet tfgetok "d.GetOk()" b
if v, ok := d.GetOk("$1"); ok {
	$0
}
endsnippet


snippet tfcallcreate "call sdk CreateOrUpdate() in sync manner" b
if _, err := client.CreateOrUpdate(ctx, resourceGroup, name, params); err != nil {
	return fmt.Errorf("Error creating $1 %q (Resource Group %q): %+v", name, resourceGroup, err)
}
endsnippet

snippet tfcallcreate_async "call sdk CreateOrUpdate() in async manner" b
future, err := client.CreateOrUpdate(ctx, resourceGroup, name, params)
if err != nil {
	return fmt.Errorf("Error creating $1 %q (Resource Group %q): %+v", name, resourceGroup, err)
}

if err := future.WaitForCompletionRef(ctx, client.Client); err != nil {
	return fmt.Errorf("Error waiting for creation of $1 %q (Resource Group %q): %+v", name, resourceGroup, err)
}
endsnippet

snippet tfsetid "set id in resource data" b
read, err := client.Get(ctx, resourceGroup, name, "")
if err != nil {
	return fmt.Errorf("Error retrieving $1 %q (Resource Group %q): %+v", name, resourceGroup, err)
}

if read.ID == nil {
	return fmt.Errorf("Error retrieving $1 %q (Resource Group %q): `id` was nil", name, resourceGroup)
}

d.SetId(*read.ID)
endsnippet

snippet tfretcreate "return statement of create callback" b
return resource$1Read(d, meta)
endsnippet

snippet tfparseid "parse resource id" b
id, err := Parse$1ID(d.Id())
if err != nil {
	return err
}
endsnippet

snippet tfcallget "call sdk Get() in read callback" b
resp, err := client.Get(ctx, id.ResourceGroup, id.Name, "")
if err != nil {
	if utils.ResponseWasNotFound(resp.Response) {
		log.Printf("[DEBUG] $1 %q was not found in Resource Group %q - removing from state!", id.Name, id.ResourceGroup)
		d.SetId("")
		return nil
	}

	return fmt.Errorf("Error retrieving $1 %q (Resource Group %q): %+v", id.Name, id.ResourceGroup, err)
}
endsnippet

snippet tfretread "return statement of read callback" b
return tags.FlattenAdnSet(d, resp.Tags)
endsnippet

snippet tfcallupdate "call sdk Update() in sync manner" b
if _, err := client.Update(ctx, id.ResourceGroup, id.Name, params); err != nil {
	return fmt.Errorf("Error updating $1 %q (Resource Group %q): %+v", name, resourceGroup, err)
}
endsnippet

snippet tfcallupdate_async "call sdk Update() in async manner" b
future, err := client.Update(ctx, id.ResourceGroup, id.Name, params)
if err != nil {
	return fmt.Errorf("Error updating $1 %q (Resource Group %q): %+v", id.Name, id.ResourceGroup, err)
}
if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
	return fmt.Errorf("Error waiting for update of $1 %q (Resource Group %q): %+v", id.Name, id.ResourceGroup, err)
}
endsnippet

snippet tfretupdate "return statement of update callback" b
return resource$1Read(d, meta)
endsnippet

snippet tfcalldelete_async "call sdk Delete() in async manner" b
future, err := client.Delete(ctx, id.ResourceGroup, id.Name)
if err != nil {
	return fmt.Errorf("Error deleting $1 %q (Resource Group %q): %+v", id.Name, id.ResourceGroup, err)
}

if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
	if !response.WasNotFound(future.Response()) {
		return fmt.Errorf("Error waiting for deleting $1 %q (Resource Group %q): %+v", id.Name, id.ResourceGroup, err)
	}
}
endsnippet

snippet tfcalldelete "call sdk Delete() in manner" b
if _, err := client.Delete(ctx, id.ResourceGroup, id.Name); err != nil {
	return fmt.Errorf("Error deleting $1 %q (Resource Group %q): %+v", id.Name, id.ResourceGroup, err)
}
endsnippet

snippet tfretdelete "return statement of delete callback" b
return nil
endsnippet

snippet tfflatten_map "define flatten function which converts sdk type into nested block (i.e. one length slice of map)" b
func flatten$1(input $2) []interface{} {
	if input == nil {
		return []interface{}{}
	}

	$0

	return []interface{
		map[string]interface{}{
		},
	}
}
endsnippet

snippet tfflatten_slice "define flatten function which converts pointer of slice of sdk type into slice" b
func flatten$1(input *[]$2) []interface{} {
	if input == nil {
		return []interface{}{}
	}

	output := make([]interface{}, 0)

	for _, v := range *input {
		output = append(output, $3)
	}

	return output
}
endsnippet

snippet tfexpand_map "define expand function which converts nested block to sdk type" b
func expand$1(input []interface{}) *$2 {
	if len(input) == 0 {
		return nil
	}

	raw := input[0].(map[string]interface{})
	output := &$2{
	}

	return output
}
endsnippet

snippet tfexpand_slice "define expand function which converts slice to pointer of slice of sdk type" b
func expand$1(input []interface{}) *[]$2 {
	result := make([]$2, 0)

	for _, v := range input {
		result = append(result, $3)			
	}

	return &result
}
endsnippet

snippet tfparseiddef "define parseid function" b
import (
	"fmt"

	"github.com/terraform-providers/terraform-provider-azurerm/azurerm/helpers/azure"
)

type $1Id struct {
	ResourceGroup string
	Name string
}

func $1ID(input string) (*$1Id, error) {
	id, err := azure.ParseAzureResourceID(input)
	if err != nil {
		return nil, fmt.Errorf("[ERROR] Unable to parse ${1/([A-Z][a-z]+)/$1 /g}ID %q: %+v", input, err)
	}

	server := $1Id {
		ResourceGroup: id.ResourceGroup,	
	}

	if server.Name, err = id.PopSegment("$2"); err != nil {
		return nil, err
	}

	if err := id.ValidateNoEmptySegments(input); err != nil {
		return nil, err
	}

	return &server, nil
}
endsnippet

snippet tfparseidtest "define ut for parseid function" b
import (
	"testing"
)

func Test$1ID(t *testing.T) {
	testData := []struct {
		Name   string
		Input  string
		Error  bool
		Expect *$1Id
	}{
		{
			Name:  "Empty",
			Input: "",
			Error: true,
		},
		{
			Name:  "No Resource Groups Segment",
			Input: "/subscriptions/00000000-0000-0000-0000-000000000000",
			Error: true,
		},
		{
			Name:  "No Resource Groups Value",
			Input: "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/",
			Error: true,
		},
		{
			Name:  "No Resource Group ID",
			Input: "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/foo/",
			Error: true,
		},
	}

	for _, v := range testData {
		t.Logf("[DEBUG] Testing %q", v.Name)

		actual, err := $1ID(v.Input)
		if err != nil {
			if v.Error {
				continue
			}

			t.Fatalf("Expected a value but got an error: %s", err)
		}

		if actual.ResourceGroup != v.Expect.ResourceGroup {
			t.Fatalf("Expected %q but got %q for Resource Group", v.Expect.ResourceGroup, actual.ResourceGroup)
		}

		if actual.Name != v.Expect.Name {
			t.Fatalf("Expected %q but got %q for Name", v.Expect.Name, actual.Name)
		}

	}
}
endsnippet
